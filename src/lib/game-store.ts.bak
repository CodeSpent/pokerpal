/**
 * In-memory game store for MVP
 *
 * In production, this would be replaced with Redis + PostgreSQL
 * This allows the game to run without external dependencies initially
 */

import type { TournamentState, TableState, Player, TournamentConfig, DeckState } from './poker-engine/types';
import { createTable, startHand, postBlinds, dealHoleCardsToPlayers } from './poker-engine/table-controller';
import { getBlindLevel, STANDARD_SNG_STRUCTURE } from './poker-engine/blind-structures';
import { getDefaultPayoutStructure } from './poker-engine/payout-structures';

import * as fs from 'fs';
import * as path from 'path';

// File-based persistence for development (Turbopack doesn't preserve memory between workers)
const STORE_FILE = path.join(process.cwd(), '.game-store.json');

interface SerializedStore {
  tournaments: [string, TournamentState][];
  tables: [string, TableState][];
  players: [string, Player][];
  tableDecks: [string, DeckState][];
}

// In-memory stores
let tournaments = new Map<string, TournamentState>();
let tables = new Map<string, TableState>();
let players = new Map<string, Player>();
let tableDecks = new Map<string, DeckState>();

// Load from file on startup
function loadFromFile() {
  try {
    if (fs.existsSync(STORE_FILE)) {
      const data = fs.readFileSync(STORE_FILE, 'utf-8');
      const parsed: SerializedStore = JSON.parse(data);
      tournaments = new Map(parsed.tournaments || []);
      tables = new Map(parsed.tables || []);
      players = new Map(parsed.players || []);
      tableDecks = new Map(parsed.tableDecks || []);
      console.log('[GameStore] Loaded from file. T:', tournaments.size, 'Tbl:', tables.size);
    } else {
      console.log('[GameStore] No store file found, starting fresh');
    }
  } catch (err) {
    console.log('[GameStore] Failed to load from file, starting fresh');
    tournaments = new Map();
    tables = new Map();
    players = new Map();
    tableDecks = new Map();
  }
}

// Save to file after modifications
function saveToFile() {
  try {
    const data: SerializedStore = {
      tournaments: Array.from(tournaments.entries()),
      tables: Array.from(tables.entries()),
      players: Array.from(players.entries()),
      tableDecks: Array.from(tableDecks.entries()),
    };
    fs.writeFileSync(STORE_FILE, JSON.stringify(data), 'utf-8');
  } catch (err) {
    console.error('[GameStore] Failed to save to file:', err);
  }
}

// Load on module initialization
loadFromFile();

// ============================================
// PLAYER OPERATIONS
// ============================================

export function getPlayer(playerId: string): Player | undefined {
  return players.get(playerId);
}

export function createPlayer(player: Player): Player {
  players.set(player.id, player);
  saveToFile();
  return player;
}

export function updatePlayer(playerId: string, updates: Partial<Player>): Player | undefined {
  const existing = players.get(playerId);
  if (!existing) return undefined;

  const updated = { ...existing, ...updates };
  players.set(playerId, updated);
  saveToFile();
  return updated;
}

// ============================================
// TOURNAMENT OPERATIONS
// ============================================

export function getTournament(tournamentId: string): TournamentState | undefined {
  return tournaments.get(tournamentId);
}

export function getAllTournaments(): TournamentState[] {
  return Array.from(tournaments.values());
}

export function getOpenTournaments(): TournamentState[] {
  return Array.from(tournaments.values()).filter(
    (t) => t.status === 'registering'
  );
}

export function createTournament(config: TournamentConfig): TournamentState {
  const id = crypto.randomUUID();

  const state: TournamentState = {
    id,
    config,
    status: 'registering',
    registeredPlayers: [],
    earlyStart: {
      isVotingActive: false,
      initiatedBy: null,
      initiatedAt: null,
      votes: [],
    },
    tables: [],
    currentLevel: 1,
    levelStartedAt: null,
    nextLevelAt: null,
    eliminationOrder: [],
    playersRemaining: 0,
    prizePool: 0,
    payouts: {},
    createdAt: Date.now(),
    startedAt: null,
    endedAt: null,
  };

  tournaments.set(id, state);
  saveToFile();
  return state;
}

export function updateTournament(
  tournamentId: string,
  updates: Partial<TournamentState>
): TournamentState | undefined {
  const existing = tournaments.get(tournamentId);
  if (!existing) return undefined;

  const updated = { ...existing, ...updates };
  tournaments.set(tournamentId, updated);
  saveToFile();
  return updated;
}

export function registerForTournament(
  tournamentId: string,
  player: Player
): { success: boolean; error?: string; tournament?: TournamentState } {
  const tournament = tournaments.get(tournamentId);

  if (!tournament) {
    return { success: false, error: 'Tournament not found' };
  }

  if (tournament.status !== 'registering') {
    return { success: false, error: 'Tournament is not open for registration' };
  }

  if (tournament.registeredPlayers.length >= tournament.config.maxPlayers) {
    return { success: false, error: 'Tournament is full' };
  }

  if (tournament.registeredPlayers.some((p) => p.id === player.id)) {
    return { success: false, error: 'Already registered' };
  }

  tournament.registeredPlayers.push(player);
  tournaments.set(tournamentId, tournament);
  saveToFile();

  return { success: true, tournament };
}

export function unregisterFromTournament(
  tournamentId: string,
  playerId: string
): { success: boolean; error?: string } {
  const tournament = tournaments.get(tournamentId);

  if (!tournament) {
    return { success: false, error: 'Tournament not found' };
  }

  if (tournament.status !== 'registering') {
    return { success: false, error: 'Cannot unregister after tournament starts' };
  }

  const index = tournament.registeredPlayers.findIndex((p) => p.id === playerId);
  if (index === -1) {
    return { success: false, error: 'Not registered' };
  }

  tournament.registeredPlayers.splice(index, 1);

  // Also remove their vote if they had one
  const voteIndex = tournament.earlyStart.votes.findIndex((v) => v.playerId === playerId);
  if (voteIndex !== -1) {
    tournament.earlyStart.votes.splice(voteIndex, 1);
  }

  tournaments.set(tournamentId, tournament);
  saveToFile();

  return { success: true };
}

// ============================================
// EARLY START VOTING
// ============================================

export function initiateEarlyStart(
  tournamentId: string,
  playerId: string
): { success: boolean; error?: string; tournament?: TournamentState } {
  const tournament = tournaments.get(tournamentId);

  if (!tournament) {
    return { success: false, error: 'Tournament not found' };
  }

  if (tournament.status !== 'registering') {
    return { success: false, error: 'Tournament is not in registration phase' };
  }

  // Only the creator can initiate a vote
  if (tournament.config.creatorId !== playerId) {
    return { success: false, error: 'Only the host can initiate early start' };
  }

  if (tournament.registeredPlayers.length < 2) {
    return { success: false, error: 'Need at least 2 players to start' };
  }

  // Start voting (host automatically votes yes)
  tournament.earlyStart = {
    isVotingActive: true,
    initiatedBy: playerId,
    initiatedAt: Date.now(),
    votes: [{ playerId, votedAt: Date.now() }],
  };

  tournaments.set(tournamentId, tournament);
  saveToFile();
  return { success: true, tournament };
}

export function voteEarlyStart(
  tournamentId: string,
  playerId: string
): { success: boolean; error?: string; tournament?: TournamentState } {
  const tournament = tournaments.get(tournamentId);

  if (!tournament) {
    return { success: false, error: 'Tournament not found' };
  }

  if (tournament.status !== 'registering') {
    return { success: false, error: 'Tournament is not in registration phase' };
  }

  if (!tournament.earlyStart.isVotingActive) {
    return { success: false, error: 'No active vote' };
  }

  // Check if player is registered
  if (!tournament.registeredPlayers.some((p) => p.id === playerId)) {
    return { success: false, error: 'Not registered for this tournament' };
  }

  // Check if already voted
  if (tournament.earlyStart.votes.some((v) => v.playerId === playerId)) {
    return { success: false, error: 'Already voted' };
  }

  // Add vote
  tournament.earlyStart.votes.push({ playerId, votedAt: Date.now() });

  tournaments.set(tournamentId, tournament);
  saveToFile();
  return { success: true, tournament };
}

export function cancelEarlyStart(
  tournamentId: string,
  playerId: string
): { success: boolean; error?: string; tournament?: TournamentState } {
  const tournament = tournaments.get(tournamentId);

  if (!tournament) {
    return { success: false, error: 'Tournament not found' };
  }

  // Only the creator can cancel
  if (tournament.config.creatorId !== playerId) {
    return { success: false, error: 'Only the host can cancel early start' };
  }

  tournament.earlyStart = {
    isVotingActive: false,
    initiatedBy: null,
    initiatedAt: null,
    votes: [],
  };

  tournaments.set(tournamentId, tournament);
  saveToFile();
  return { success: true, tournament };
}

export function forceEarlyStart(
  tournamentId: string,
  playerId: string
): { success: boolean; error?: string } {
  const tournament = tournaments.get(tournamentId);

  if (!tournament) {
    return { success: false, error: 'Tournament not found' };
  }

  // Only the creator can force start
  if (tournament.config.creatorId !== playerId) {
    return { success: false, error: 'Only the host can force start' };
  }

  if (tournament.registeredPlayers.length < 2) {
    return { success: false, error: 'Need at least 2 players to start' };
  }

  // The actual start will be handled by startTournament
  return { success: true };
}

export function startTournament(
  tournamentId: string
): { success: boolean; error?: string; tables?: TableState[] } {
  const tournament = tournaments.get(tournamentId);

  if (!tournament) {
    return { success: false, error: 'Tournament not found' };
  }

  if (tournament.status !== 'registering') {
    return { success: false, error: 'Tournament already started' };
  }

  const playerCount = tournament.registeredPlayers.length;

  if (playerCount < 2) {
    return { success: false, error: 'Need at least 2 players' };
  }

  // Create tables
  const tableSize = tournament.config.tableSize;
  const numTables = Math.ceil(playerCount / tableSize);
  const createdTables: TableState[] = [];

  const blindLevel = getBlindLevel(STANDARD_SNG_STRUCTURE, 1);

  for (let i = 0; i < numTables; i++) {
    const table = createTable(
      crypto.randomUUID(),
      tournamentId,
      i + 1,
      tableSize,
      blindLevel.smallBlind,
      blindLevel.bigBlind,
      blindLevel.ante
    );
    createdTables.push(table);
    tables.set(table.id, table);
  }

  // Assign players to tables
  const shuffledPlayers = [...tournament.registeredPlayers].sort(
    () => Math.random() - 0.5
  );

  let tableIndex = 0;
  let seatIndex = 0;

  for (const player of shuffledPlayers) {
    const table = createdTables[tableIndex];

    // Create table player
    const tablePlayer = {
      ...player,
      seatIndex,
      stack: tournament.config.startingChips,
      status: 'waiting' as const,
      currentBet: 0,
      hasActed: false,
      isAllIn: false,
      isSittingOut: false,
    };

    table.seats[seatIndex] = {
      ...table.seats[seatIndex],
      player: tablePlayer,
    };

    seatIndex++;
    if (seatIndex >= tableSize) {
      seatIndex = 0;
      tableIndex++;
    }
  }

  // Update tournament state
  const payout = getDefaultPayoutStructure(tableSize);
  const now = Date.now();

  tournament.status = 'running';
  tournament.tables = createdTables.map((t) => t.id);
  tournament.playersRemaining = playerCount;
  tournament.prizePool = playerCount * 100; // Placeholder buy-in
  tournament.startedAt = now;
  tournament.levelStartedAt = now;
  tournament.nextLevelAt = now + blindLevel.durationMinutes * 60 * 1000;

  tournaments.set(tournamentId, tournament);
  saveToFile();

  // Save tables and start first hand on each
  for (let table of createdTables) {
    // Start hand
    const { state: handState, deck, events: handEvents } = startHand(table);

    // Post blinds
    const { state: blindState, events: blindEvents } = postBlinds(handState);

    // Deal hole cards
    const { state: dealState, deck: finalDeck, holeCardsByPlayer } = dealHoleCardsToPlayers(blindState, deck);

    // Store the deck for this table
    tableDecks.set(dealState.id, finalDeck);

    // Debug logging
    console.log('[startTournament] Table:', dealState.id);
    console.log('[startTournament] Phase:', dealState.phase);
    console.log('[startTournament] currentActorSeatIndex:', dealState.currentActorSeatIndex);
    console.log('[startTournament] dealerSeatIndex:', dealState.dealerSeatIndex);
    console.log('[startTournament] bigBlindSeatIndex:', dealState.bigBlindSeatIndex);

    // Save the final state
    tables.set(dealState.id, dealState);
    saveToFile();

    // Update the table reference for return
    const idx = createdTables.findIndex(t => t.id === table.id);
    if (idx !== -1) {
      createdTables[idx] = dealState;
    }
  }

  return { success: true, tables: createdTables };
}

export function getTableDeck(tableId: string): DeckState | undefined {
  return tableDecks.get(tableId);
}

export function setTableDeck(tableId: string, deck: DeckState): void {
  tableDecks.set(tableId, deck);
  saveToFile();
}

export function deleteTableDeck(tableId: string): void {
  tableDecks.delete(tableId);
  saveToFile();
}

// ============================================
// TABLE OPERATIONS
// ============================================

export function getTable(tableId: string): TableState | undefined {
  return tables.get(tableId);
}

export function updateTable(
  tableId: string,
  updates: Partial<TableState>
): TableState | undefined {
  const existing = tables.get(tableId);
  if (!existing) return undefined;

  const updated = { ...existing, ...updates };
  tables.set(tableId, updated);
  saveToFile();
  return updated;
}

export function saveTableState(table: TableState): void {
  tables.set(table.id, table);
  saveToFile();
}

// ============================================
// CLEANUP
// ============================================

export function deleteTournament(tournamentId: string): void {
  const tournament = tournaments.get(tournamentId);
  if (tournament) {
    // Delete associated tables
    for (const tableId of tournament.tables) {
      tables.delete(tableId);
    }
    tournaments.delete(tournamentId);
    saveToFile();
  }
}

export function clearAll(): void {
  tournaments.clear();
  tables.clear();
  players.clear();
  tableDecks.clear();
  saveToFile();
}
